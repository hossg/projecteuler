# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and
# are generated by the following formulae:
#
# Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
# Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
#
# The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including
# the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a
# different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square,
# pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

# put the expected answer here
expectedAnswer=123456789



def triangular():
    n=0
    while True:
        n+=1
        yield int(n*(n+1)/2)

def square():
    n=0
    while True:
        n+=1
        yield n**2

def pentagonal():
    n=0
    while True:
        n+=1
        yield int(n*(3*n-1)/2)

def hexagonal():
    n=0
    while True:
        n+=1
        yield n*(2*n-1)

def heptagonal():
    n=0
    while True:
        n+=1
        yield int(n*(5*n-3)/2)

def octagonal():
    n=0
    while True:
        n+=1
        yield n*(3*n-2)

def four_digit(g):
    return itertools.takewhile(lambda x: len(str(x))==4, itertools.dropwhile(lambda x: len(str(x))<4,g))

def last_two_first_two(d1,d2):
    if d1 % 100 == int(d2/100):
        return True
    else:
        return False

def is_cyclic(d1,d2):
    if last_two_first_two(d1,d2) or last_two_first_two(d2,d1):
        return True
    else:
        return False

def find_cyclics(l1,l2):
    cyclics=[]
    for i1 in l1:
        for i2 in l2:
            if is_cyclic(i1,i2):
                cyclics.append(i1)
    return set(cyclics)



import logging, math, timeit, time, platform, os,itertools #, psutil


def solution():

    t=octagonal()
    # for i in range(10):
    #     print(t.__next__())
    tri = list(four_digit(hexagonal()))
    squ = list(four_digit(square()))
    pen = list(four_digit(pentagonal()))
    hex = list(four_digit(hexagonal()))
    hep = list(four_digit(heptagonal()))
    oct = list(four_digit(octagonal()))

    sets={'tri': tri, 'squ': squ, 'pen': pen, 'hex': hex, 'hep': hep,'oct': oct}

    # print(len(oct))
    # print(len(hep))
    # print(len(hex))
    # print(len(pen))
    # print(len(squ))
    # print(len(tri))
    #
    # print(hep)
    #
    # print(find_cyclics(oct,hep))
    # print(find_cyclics(oct, hex))
    # print(find_cyclics(oct, pen))
    # print(find_cyclics(oct, squ))
    # print(find_cyclics(oct, tri))
    # print(find_cyclics(hep, oct))

    for iname,i in sets.items():
        for jname,j in sets.items():
            if j!=i:
                print('{} > {} = {}'.format(iname,jname,find_cyclics(i,j)))




    # print(last_two_first_two(1234, 3456))
    # print(last_two_first_two(1234, 3356))


    # just a placeholder for where the solution to the problem will be stored and then returned
    solution=987654321

    #implement solution to the problem here
    time.sleep(1)

    return solution


# Utility function for measuring the performance of solutions
processtime=0.0
walltime=0.0
def stopwatch():
    global walltime, processtime
    wt=time.time()
    ct=time.clock()
    wtElapsed=wt-walltime
    ctElapsed=ct-processtime
    walltime=wt
    processtime=ct
    return('Elapsed process time:{}s, Elapsed clock time:{}s'.format(ctElapsed,wtElapsed))

# def getsysteminfo():
#     p=platform.platform()+' ' +platform.processor()+' Python: '+platform.python_version()
#     memory=psutil.virtual_memory()
#     cpuc=psutil.cpu_count()
#     cpup=psutil.cpu_count(logical=True)
#     cpuf=psutil.cpu_freq()
#     cput=psutil.cpu_times_percent(percpu=False)
#
#     return 'Platform: {}, Memory: {} Physical CPUs: {}, Logical CPUs: {}, Frequency (MHz): {}, Utilisation: {}'.format\
#         (p,memory,cpuc,cpup,cpuf,cput)

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(name)s %(message)s')
    logging=logging.getLogger(os.path.basename(__file__))
    stopwatch() #start timing
    solution = solution()
    timetaken=stopwatch() #stop timing
    #assert (solution == expectedAnswer)
    logging.info('Solution = {}'.format(solution))
    logging.info(timetaken)
    # logging.info('System info: {}'.format(getsysteminfo()))