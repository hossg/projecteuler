# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and
# are generated by the following formulae:
#
# Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
# Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
#
# The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including
# the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a
# different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square,
# pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

# put the expected answer here
expectedAnswer=28684

import logging, math, timeit, time, platform, os,itertools , psutil

# some generator functions to create the polygonal numbers we want

def triangular():
    n=0
    while True:
        n+=1
        yield int(n*(n+1)/2)

def square():
    n=0
    while True:
        n+=1
        yield n**2

def pentagonal():
    n=0
    while True:
        n+=1
        yield int(n*(3*n-1)/2)

def hexagonal():
    n=0
    while True:
        n+=1
        yield n*(2*n-1)

def heptagonal():
    n=0
    while True:
        n+=1
        yield int(n*(5*n-3)/2)

def octagonal():
    n=0
    while True:
        n+=1
        yield n*(3*n-2)

# an iterator to give us only 4-digit numbers
def four_digit(g):
    return itertools.takewhile(lambda x: len(str(x))==4, itertools.dropwhile(lambda x: len(str(x))<4,g))

# simple function to confirm cyclicity
def is_cyclic(d1,d2):
    if d1 % 100 == int(d2/100):
        return True
    else:
        return False

# given a number and a set, return the subset that is cyclic with the provided number
def get_cyclic_subset(number, starting_set):
    results = []
    for n in starting_set:
        if is_cyclic(number,n):
            results.append(n)
    return results

def solution():

    # prepare our sets of polygonals
    tri = {'tri': sorted(list(four_digit(triangular())))}
    squ = {'squ': sorted(list(four_digit(square())))}
    pen = {'pen': sorted(list(four_digit(pentagonal())))}
    hex = {'hex': sorted(list(four_digit(hexagonal())))}
    hep = {'hep': sorted(list(four_digit(heptagonal())))}
    oct = {'oct': sorted(list(four_digit(octagonal())))}

    sets = {'tri': tri, 'squ': squ, 'pen': pen, 'hex': hex, 'hep': hep, 'oct': oct}

    # note: the dict-based naming is a convenience in case we want to reverse the process at any point and identify
    # which polygonal a particular number might be.  Unused capability in the solution of the problem.

    # first assemble the different ordering/sequences of possible polygonal numbers
    combos = itertools.permutations(sets.keys(),6)
    polygonal_sequences=set()
    for n,i in enumerate(combos):
        if(i[0]=='oct'): # by picking only those that start with 'oct' (or any other fixed starting point) we eliminate duplicates that have the same (circluar) ordering/sequence
            polygonal_sequences.add(i)

    # for each sequence of polygonals
    # for each polygonal,
    # for each number, find the set of numbers from the next polygonal that are cyclic with it,
    # and for each of these, rinse and repeat

    results=[]
    for sequence in polygonal_sequences:
        seq = list(sequence)
        logging.debug("Checking sequence {}".format(seq))
        set0 = sets[seq[0]][seq[0]]
        for n0 in set0:
            set1 = get_cyclic_subset(n0,sets[seq[1]][seq[1]])

            for n1 in set1:
                set2 = get_cyclic_subset(n1, sets[seq[2]][seq[2]])

                for n2 in set2:
                    set3 = get_cyclic_subset(n2, sets[seq[3]][seq[3]])

                    for n3 in set3:
                        set4 = get_cyclic_subset(n3, sets[seq[4]][seq[4]])

                        for n4 in set4:
                            set5 = get_cyclic_subset(n4, sets[seq[5]][seq[5]])

                            for n5 in set5:
                                if is_cyclic(n5,n0):    # having got to this point, we need to confirm the last number is cyclic with the first
                                    r = [n0, n1, n2, n3, n4, n5]
                                    results=r
                                    break

    #and calculate the sum of the cyclic sequence
    sum = 0
    for i in results:
        sum+=i

    # just a placeholder for where the solution to the problem will be stored and then returned
    solution=sum
    return solution


# Utility function for measuring the performance of solutions
processtime=0.0
walltime=0.0
def stopwatch():
    global walltime, processtime
    wt=time.time()
    ct=time.clock()
    wtElapsed=wt-walltime
    ctElapsed=ct-processtime
    walltime=wt
    processtime=ct
    return('Elapsed process time:{}s, Elapsed clock time:{}s'.format(ctElapsed,wtElapsed))

def getsysteminfo():
    p=platform.platform()+' ' +platform.processor()+' Python: '+platform.python_version()
    memory=psutil.virtual_memory()
    cpuc=psutil.cpu_count()
    cpup=psutil.cpu_count(logical=True)
    cpuf=psutil.cpu_freq()
    cput=psutil.cpu_times_percent(percpu=False)

    return 'Platform: {}, Memory: {} Physical CPUs: {}, Logical CPUs: {}, Frequency (MHz): {}, Utilisation: {}'.format\
        (p,memory,cpuc,cpup,cpuf,cput)

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(name)s %(message)s')
    logging=logging.getLogger(os.path.basename(__file__))
    stopwatch() #start timing
    solution = solution()
    timetaken=stopwatch() #stop timing
    assert (solution == expectedAnswer)
    logging.info('Solution = {}'.format(solution))
    logging.info(timetaken)
    logging.info('System info: {}'.format(getsysteminfo()))